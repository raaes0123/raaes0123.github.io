<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css" />
    <link rel="stylesheet" href="../media.css" />
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <title>FreeRTOS Queue</title>
</head>

<body>
    <header></header>
    <script src="header_script.js"></script> 
    <hr>
    <!--<div id="project_container" style="margin-left: 2%; margin-top: 0.8%; align-items: center; display: flex; flex-direction: column">-->
    <div class="project-container">
        <div id="project-title">
            <p>FreeRTOS Queue</p>
        </div>
        <p>
            This example demonstrates a queue being created, data being sent to the queue from multiple
            tasks, and data being received from the queue. The queue is created to hold data items of
            type int32_t. The tasks that send to the queue do not specify a block time, whereas the task
            that receives from the queue does.
        </p>
        <p>
            The priority of the tasks that send to the queue are lower than the priority of the task that
            receives from the queue. This means the queue should never contain more than one item
            because, as soon as data is sent to the queue the receiving task will unblock, pre-empt the
            sending task, and remove the dataâ€”leaving the queue empty once again.
        </p>
<pre>
    /*
    FreeRTOS Task example to demonstrate queue
    */

    /* FreeRTOS includes. */
    #include &ltstddef.h&gt
    #include &ltFreeRTOS.h&gt
    #include &lttask.h&gt
    #include &ltqueue.h&gt
    #include &lttimers.h&gt
    #include &ltsemphr.h&gt
    #include "main.h"

    void u32ToStr(uint32_t value, char *buffer)
    {
        char temp[11]; // max 10 digits + null terminator
        int i = 0, j = 0;

        // Handle 0 explicitly
        if (value == 0) {
            buffer[0] = '0';
            buffer[1] = '\0';
            return;
        }

        // Extract digits in reverse
        while (value > 0) {
            temp[i++] = (value % 10) + '0';
            value /= 10;
        }

        // Reverse into buffer
        while (i > 0) {
            buffer[j++] = temp[--i];
        }
        buffer[j] = '\0';
    }


    static void vPrintString(const char *str){
        uint8_t i = 0;
        while(str[i] != '\0'){
            USART_DR = str[i];
            while(!(USART_SR &(1 << TXE)));
            i++;
        }
    }

    void *memset(void *s, int c, size_t n) {
        unsigned char *ptr = s;
        while (n--) {
            *ptr++ = (unsigned char)c;
        }
        return s;
    }

    void *memcpy(void *d, void *s, size_t n) {
        unsigned char *sptr = s;
        unsigned char *dptr = d;
        while (n--) {
            *dptr++ = *sptr++;
        }
        return d;
    }

    // Declare a queue
    QueueHandle_t xQueue;

    void vSenderTask(void *pvParameters)
    {
        BaseType_t xStatus;
        int8_t ucVal = *((uint8_t*)pvParameters);
        while (1)
        {

            // Send data to the queue
            xStatus = xQueueSendToBack(xQueue,&ucVal,0);
            if(xStatus != pdPASS)
                vPrintString("Couldn't add to the queue as it is full.\r\n");
            vTaskDelay(pdMS_TO_TICKS(100));
        }
    }
    void vReceiverTask(void *pvParameters)
    {
        BaseType_t xStatus;
        int8_t ucVal;
        const TickType_t xTickToWait = pdMS_TO_TICKS(1000);
        while (1)
        {
            // Receive data from the queue
            xStatus = xQueueReceive(xQueue,&ucVal,xTickToWait);
            if(xStatus == pdPASS){
                char str[5];
                u32ToStr(ucVal,str);
                vPrintString("Received data: ");
                vPrintString(str);
                vPrintString("\r\n");
            }
            else
                vPrintString("Couldn't get data from the queue as it is empty.\r\n");
            vTaskDelay(pdMS_TO_TICKS(1000));
        }
    }


    void vApplicationTickHook(void){

    }

    void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
    {
        // This function is called if a stack overflow is detected.
        // You can log, halt the system, blink an LED, etc.
        //vPrintString("Stack overflow in task: %s\n", pcTaskName);
        //taskDISABLE_INTERRUPTS();
        for (;;);  // Stay here to halt the system
    }


    void vApplicationMallocFailedHook(void){

    }

    static void prvSetupHardware(){
        // 1. Enable GPIOA clock
        RCC_APB2ENR |= (1 << 2);  // Bit 2 = GPIOAEN
        // 2. Set PA9 and PA10 as TXD and RXD respectively
        GPIOA_CRH &= ~(3 << 4*(10-8));     // Clear MODE2 RXD(PA10) as input

        GPIOA_CRH &= ~(3 << 4*(9-8));    // Clear MODE2 TXD(PA9) as output 10MHz
        GPIOA_CRH |=  (1 << 4*(9-8));  

        GPIOA_CRH &= ~(3 << 4*(8-8));    // Clear MODE2 (PA8) as output 10MHz
        GPIOA_CRH |=  (1 << 4*(8-8));       

        // CNF (Floating input)
        GPIOA_CRH &= ~(3 << (4*(10-8)+2));     // Clear CNF2 (00)
        GPIOA_CRH |= 1 << (4*(10-8)+2);        // CNF2 (01)

        // CNF (Alternate function push-pull 10) TXD
        GPIOA_CRH &= ~(3 << (4*(9-8)+2));     // Clear CNF2 (00)
        GPIOA_CRH |= 2 << (4*(9-8)+2);        // CNF2 (10)

        GPIOA_CRH &= ~(3 << (4*(8-8)+2));     // Clear CNF2 (00) GPIO Push-pull

        // UART
        // 1. Enable UART Clock
        RCC_APB2ENR |= (1 << USART1EN);
        // Set baud rate
        USART_BRR &= ~(0xFFFF);
        USART_BRR |= 0x08B;                    // BR = 57600 (8Mhz HSI)
        // Enable Transmitter, Receiver and UART
        USART_CR1 |= 1 << TE;
        USART_CR1 |= 1 << RE;
        USART_CR1 |= 1 << UE;
    }


    void main(void)
    {
        // Hardware Setup
        prvSetupHardware();
        
        // Define queue to have 5 uint8_t values
        xQueue = xQueueCreate(5,sizeof(uint8_t));

        if(xQueue){
            // Task parameters
            TaskFunction_t pvTaskCode = vSenderTask;    // Pointer to the function that implements the task
            const char * const pcName = "Sender_1";     // Descriptive name of the task
            uint16_t usStackDepth = 128;                // Stack size 
            uint8_t pvParam_1 = 100;                    // Parameters passed in to the task by Sender_1
            uint8_t pvParam_2 = 200;                    // Parameters passed in to the task by Sender_1
            UBaseType_t uxPriority = 1;                 // Task priority for senders
            TaskHandle_t *pxSenderTaskH_1 = NULL;        // Task handle for Sender_1
            TaskHandle_t *pxSenderTaskH_2 = NULL;        // Task handle for Sender_1
            TaskHandle_t *pxReceiverTaskH = NULL;        // Task handle for Receiver
            // Create 2 sender tasks
            xTaskCreate(pvTaskCode, pcName, usStackDepth, (void*)&pvParam_1, uxPriority, pxSenderTaskH_1);
            xTaskCreate(pvTaskCode, "Sender_2", usStackDepth, (void*)&pvParam_2, uxPriority, pxSenderTaskH_2);
            // Create 1 receiver task
            xTaskCreate((TaskFunction_t)vReceiverTask, "Receiver", usStackDepth, NULL, 1, pxReceiverTaskH);

            vTaskStartScheduler();
        }
        else{
            vPrintString("Queue couldn't be created.\r\n");
        }

        while(1); // Should never reach here
    }


</pre>
    </div>
</body>
</html>